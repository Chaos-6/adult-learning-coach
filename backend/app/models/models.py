"""
SQLAlchemy models — these define the database tables.

Each class maps to a PostgreSQL table. The columns become table columns.
Relationships (ForeignKey) link tables together.

The PRD defines 6 tables. We're implementing these for MVP + comparison:
- organizations: Multi-tenant grouping
- users: Instructors, coaches, admins
- videos: Uploaded training session recordings
- transcripts: Time-stamped text from video transcription
- evaluations: AI-generated coaching analysis results
- comparisons: Multi-video cross-session analysis
- comparison_evaluations: M:N join linking comparisons to evaluations
"""

import uuid
from datetime import datetime

from sqlalchemy import (
    BigInteger,
    Boolean,
    Column,
    DateTime,
    ForeignKey,
    Integer,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import ARRAY, JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from app.database import Base


class Organization(Base):
    """A company or institution that subscribes to the service.

    This enables multi-tenancy — each org sees only their own data.
    Maps to the PRD's subscription tiers (starter/professional/enterprise).
    """
    __tablename__ = "organizations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    subscription_tier = Column(String(50), nullable=False, default="starter")
    max_evaluations_per_month = Column(Integer, nullable=False, default=10)
    max_users = Column(Integer, nullable=False, default=6)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    billing_email = Column(String(255))

    # Relationships
    users = relationship("User", back_populates="organization")


class User(Base):
    """A person who uses the system.

    Three roles (from the PRD):
    - instructor: Uploads videos, views their own reports
    - coach: Reviews AI-generated reports before sharing
    - admin: Manages users, configures rubrics, views analytics
    """
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    display_name = Column(String(255), nullable=False)
    role = Column(String(50), nullable=False)  # 'instructor', 'coach', 'admin'
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    last_login = Column(DateTime(timezone=True))
    is_active = Column(Boolean, default=True)

    # Relationships
    organization = relationship("Organization", back_populates="users")
    videos = relationship("Video", back_populates="instructor")


class Video(Base):
    """An uploaded training session recording.

    Videos go through this lifecycle:
    uploading → uploaded → transcribing → transcribed → analyzing → completed

    The PRD supports MP4, MOV, WebM, AVI up to 10GB.
    """
    __tablename__ = "videos"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    instructor_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    filename = Column(String(500), nullable=False)
    s3_key = Column(String(500), nullable=False, default="")
    file_size_bytes = Column(BigInteger, nullable=False)
    duration_seconds = Column(Integer)
    format = Column(String(50))  # 'mp4', 'mov', 'webm', 'avi'
    upload_status = Column(String(50), default="uploaded")
    uploaded_at = Column(DateTime(timezone=True), server_default=func.now())
    metadata_ = Column("metadata", JSONB, default=dict)  # topic, date, session_number

    # Relationships
    instructor = relationship("User", back_populates="videos")
    transcript = relationship("Transcript", back_populates="video", uselist=False)
    evaluations = relationship("Evaluation", back_populates="video")


class Transcript(Base):
    """Time-stamped, speaker-diarized text from a video.

    Generated by AssemblyAI. Format:
    [HH:MM:SS] Speaker A: text content here
    [HH:MM:SS] Speaker B: response text here

    One video has exactly one transcript (uselist=False above).
    """
    __tablename__ = "transcripts"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    video_id = Column(
        UUID(as_uuid=True),
        ForeignKey("videos.id", ondelete="CASCADE"),
        unique=True,
        nullable=False,
    )
    transcript_text = Column(Text, nullable=False)
    word_count = Column(Integer, nullable=False)
    speaker_count = Column(Integer)
    processing_time_seconds = Column(Integer)
    assemblyai_transcript_id = Column(String(255))
    status = Column(String(50), default="processing")  # processing, completed, failed
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    video = relationship("Video", back_populates="transcript")


class Evaluation(Base):
    """An AI-generated coaching analysis of a teaching session.

    This is the core output of the system. Claude analyzes the transcript
    and produces:
    - A structured markdown report (8,000-15,000 words)
    - Extracted metrics (WPM, pauses, questions, etc.)
    - Categorized strengths and growth opportunities
    - Two PDFs (full report + reflection worksheet)

    Lifecycle: queued → analyzing → completed → reviewed → shared
    """
    __tablename__ = "evaluations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    video_id = Column(
        UUID(as_uuid=True),
        ForeignKey("videos.id", ondelete="CASCADE"),
        nullable=False,
    )
    transcript_id = Column(UUID(as_uuid=True), ForeignKey("transcripts.id"))
    instructor_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    coach_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))

    # Status tracking
    status = Column(String(50), default="queued")
    processing_started_at = Column(DateTime(timezone=True))
    processing_completed_at = Column(DateTime(timezone=True))

    # Analysis outputs
    report_markdown = Column(Text)
    report_pdf_s3_key = Column(String(500))
    worksheet_pdf_s3_key = Column(String(500))

    # Extracted metrics for historical tracking
    # Example: {wpm: 145, pauses_per_10min: 4.2, questions_per_5min: 1.3, ...}
    metrics = Column(JSONB, default=dict)

    # Coaching content
    strengths = Column(JSONB, default=list)       # [{text, timestamp, segment}]
    growth_opportunities = Column(JSONB, default=list)

    created_at = Column(DateTime(timezone=True), server_default=func.now())
    shared_at = Column(DateTime(timezone=True))
    viewed_at = Column(DateTime(timezone=True))

    # Relationships
    video = relationship("Video", back_populates="evaluations")
    comparison_links = relationship("ComparisonEvaluation", back_populates="evaluation")


class Comparison(Base):
    """A cross-session analysis comparing multiple coaching evaluations.

    Three comparison types, each with a different analytical lens:
    - personal_performance: Same instructor, multiple sessions → improvement tracking
    - class_delivery: Same class, different instructors → delivery variation
    - program_evaluation: Sample from a program → programmatic consistency

    The comparison analyzes existing evaluation reports (not raw transcripts)
    to stay within Claude's token budget. 10 reports ≈ 80K tokens vs.
    10 transcripts ≈ 500K tokens.

    Lifecycle: draft → queued → analyzing → completed/failed
    """
    __tablename__ = "comparisons"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(500), nullable=False)
    comparison_type = Column(
        String(50), nullable=False
    )  # 'personal_performance', 'class_delivery', 'program_evaluation'
    status = Column(String(50), default="draft")  # draft, queued, analyzing, completed, failed

    # Ownership
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"))
    created_by_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)

    # Comparison-specific settings
    class_tag = Column(String(200))  # For class_delivery: groups by class name
    anonymize_instructors = Column(Boolean, default=False)

    # Analysis outputs (same shape as Evaluation for consistency)
    report_markdown = Column(Text)
    metrics = Column(JSONB, default=dict)
    strengths = Column(JSONB, default=list)
    growth_opportunities = Column(JSONB, default=list)

    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    processing_started_at = Column(DateTime(timezone=True))
    processing_completed_at = Column(DateTime(timezone=True))

    # Relationships
    organization = relationship("Organization")
    created_by = relationship("User")
    evaluation_links = relationship(
        "ComparisonEvaluation",
        back_populates="comparison",
        order_by="ComparisonEvaluation.display_order",
    )


class ComparisonEvaluation(Base):
    """Join table linking comparisons to evaluations (many-to-many).

    This allows:
    - One comparison to include 2-10 evaluations
    - One evaluation to appear in multiple comparisons
    - Extra metadata per link: display ordering and optional labels
      (e.g., "Session 1", "Instructor A")
    """
    __tablename__ = "comparison_evaluations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    comparison_id = Column(
        UUID(as_uuid=True),
        ForeignKey("comparisons.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    evaluation_id = Column(
        UUID(as_uuid=True),
        ForeignKey("evaluations.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    display_order = Column(Integer, nullable=False, default=0)
    label = Column(String(200))  # Optional: "Session 1", "Instructor A", etc.

    # Relationships
    comparison = relationship("Comparison", back_populates="evaluation_links")
    evaluation = relationship("Evaluation", back_populates="comparison_links")
